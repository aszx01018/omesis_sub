#编写于python3.7，使用库numpy,opencv
# -*- coding: UTF-8 -*-
import numpy as np
import cv2 as cv
import time
import shutil
import ctypes

#根据范围取mask
def get_mask(img,lowerhsv,upperhsv,kernelsize):
    hsv = cv.cvtColor(img, cv.COLOR_BGR2HSV)
    got_mask = cv.inRange(hsv,lowerhsv,upperhsv)
    res = cv.morphologyEx(got_mask, cv.MORPH_OPEN, np.ones((kernelsize,kernelsize),np.uint8))
    return res
    
#从帧数计算（该帧向前取整）的时间，返回的是字符串，第一帧为00:00.00
def frame_to_time(fc,FPS):
    return ("%02d:%06.3f"%(((fc-1)/FPS)/60,((fc-1)/FPS)%60))[0:8]

#初始化空ass文件
def initial_ass(ASS_FILENAME,VIDEO_FILENAME):    
    ASS_BASE="""[Script Info]
; Script generated by Aegisub 3.2.2
; http://www.aegisub.org/
Title: New subtitles
ScriptType: v4.00+
WrapStyle: 0
PlayResX: 1920
PlayResY: 1080
ScaledBorderAndShadow: yes
YCbCr Matrix: TV.601

[Aegisub Project Garbage]
Last Style Storage: Default
Audio File: %s
Video File: %s
Video AR Mode: 4
Video AR Value: 1.777778
Video Zoom Percent: 0.375000

[V4+ Styles]
Format: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding
Style: Default,Arial,45,&H00FFFFFF,&H000000FF,&H00000000,&H00000000,0,0,0,0,100,100,0,0,1,4.5,4.5,2,30,30,23,1
Style: ray字幕,Microsoft YaHei UI,100,&H005E4EE3,&HFF0000FF,&H00FFFFFF,&H00000000,-1,0,0,0,100,100,0,0,1,6,0,2,10,10,220,1
Style: rio字幕,Microsoft YaHei UI,100,&H00D98936,&H000000FF,&H00FFFFFF,&H00000000,-1,0,0,0,100,100,0,0,1,6,0,2,10,10,220,1
Style: 薄边框注释,Microsoft YaHei UI,60,&H00FFFFFF,&H000000FF,&H00000000,&H00000000,-1,0,0,0,100,100,0,0,1,3,0,2,10,10,10,1
Style: 双色,Microsoft YaHei UI,100,&H005F4EE3,&H000000FF,&H00FFFFFF,&H00000000,-1,0,0,0,100,100,0,0,1,8,0,2,10,10,360,1

[Events]
Format: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text
Comment: 2,0:00:00.00,0:00:00.01,ray字幕,,0,0,0,template line keeptags,
Comment: 1,0:00:00.00,0:00:00.01,ray字幕,,0,0,0,template line keeptags,{\\bord9\\3c&H5F4EE3&}
Comment: 2,0:00:00.00,0:00:00.01,ray1通常,,0,0,0,template line keeptags,
Comment: 1,0:00:00.00,0:00:00.01,ray1通常,,0,0,0,template line keeptags,{\\bord7\\3c&H5F4EE3&}
Comment: 2,0:00:00.00,0:00:00.01,rio字幕,,0,0,0,template line keeptags,
Comment: 1,0:00:00.00,0:00:00.01,rio字幕,,0,0,0,template line keeptags,{\\bord9\\3c&HD98936&}
Comment: 2,0:00:00.00,0:00:00.01,rio1通常,,0,0,0,template line keeptags,
Comment: 1,0:00:00.00,0:00:00.01,rio1通常,,0,0,0,template line keeptags,{\\bord7\\3c&HD98936&}
Comment: 2,0:00:00.00,0:00:00.01,双色,,0,0,0,template line keeptags,{\\pos($sx,$sy)\\clip(!$lleft-20!,!$ltop-20!,!$lright+20!,$lmiddle)}
Comment: 1,0:00:00.00,0:00:00.01,双色,,0,0,0,template line keeptags,{\\pos($sx,$sy)\\bord12\\3c&H5F4EE3&\\clip(!$lleft-20!,!$ltop-20!,!$lright+20!,$lmiddle)}
Comment: 2,0:00:00.00,0:00:00.01,双色,,0,0,0,template line keeptags,{\\pos($sx,$sy)\\1c&HD98936&\\clip(!$lleft-20!,$lmiddle,!$lright+20!,!$lbottom+20!)}
Comment: 1,0:00:00.00,0:00:00.01,双色,,0,0,0,template line keeptags,{\\pos($sx,$sy)\\bord12\\3c&HD98936&\\1c&HD98936&\\clip(!$lleft-20!,$lmiddle,!$lright+20!,!$lbottom+20!)}
"""%(VIDEO_FILENAME,VIDEO_FILENAME)
    with open(ASS_FILENAME,"w",encoding='utf-8') as f:
        f.write(u'\ufeff') #防Aegisub乱码
        f.write(ASS_BASE)
    
#向ass中写入时间轴数据。样式为ray字幕和rio字幕
def writetimestamp(ASS_FILENAME,FPS,startframe,endframe,name='ray'):
    with open(ASS_FILENAME,'a',encoding="utf-8") as f:
        if name=='BLACK':
            f.write("Dialogue: 0,0:%s,0:%s,薄边框注释,,0,0,0,,（薄边框注释）\n"%(frame_to_time(startframe,FPS),frame_to_time(endframe,FPS)))
        else:
            f.write("Dialogue: 0,0:%s,0:%s,%s字幕,,0,0,0,,%s说：\n"%(frame_to_time(startframe,FPS),frame_to_time(endframe,FPS),name,name))
 
if __name__ == "__main__": 
    #修改终端标题
    ctypes.windll.kernel32.SetConsoleTitleW("omesis字幕轴自动生成")

    VIDEO_FILENAME = input('请输入视频文件名：\n')
    if VIDEO_FILENAME[-4:] != '.mp4':
        VIDEO_FILENAME = VIDEO_FILENAME+'.mp4'
    ASS_FILENAME = "【自动生成】"+VIDEO_FILENAME[:-4]+'.ass'
    initial_ass(ASS_FILENAME,VIDEO_FILENAME)
        
    #字幕（出现/消失）像素判定数。减小则更容易触发，更大则更难触发。宽进严出
    SUB_START_NUM = 1200
    SUB_END_NUM   = 1000
    BLACK_START_NUM = 9000
    BLACK_END_NUM   = 8000
    #WHITE_START_NUM = 9000
    #WHITE_END_NUM   = 9000
    
    LOWER_RAY = np.array([174,163,215])
    UPPER_RAY = np.array([180,170,245])
    RAY_KERNEL_SIZE = 5  #更大则更容易去噪点，但也更容易损失细节
    
    LOWER_RIO = np.array([100,170,188])
    UPPER_RIO = np.array([105,210,217])
    RIO_KERNEL_SIZE = 5
    
    LOWER_BLACK = np.array([0,0,14])
    UPPER_BLACK = np.array([179,40,46])
    BLACK_KERNEL_SIZE = 3
    #计时开始
    PROGRAM_starttime=time.time() 

    #载入视频
    cap = cv.VideoCapture(VIDEO_FILENAME,cv.CAP_FFMPEG) #打开视频
    print('成功读取视频')
    FPS = cap.get(cv.CAP_PROP_FPS)                      #帧率
    TOTAL_FRAMES = cap.get(cv.CAP_PROP_FRAME_COUNT)          #总帧数
    WIDTH = int(cap.get(cv.CAP_PROP_FRAME_WIDTH))
    HEIGHT = int(cap.get(cv.CAP_PROP_FRAME_HEIGHT))
    frame_count = 0

    #初始化空判定
    previous_RAY = np.zeros((HEIGHT//2,WIDTH//2),dtype=np.uint8)    
    previous_RAY_sum = 0
    RAY_new = np.zeros((HEIGHT//2,WIDTH//2),dtype=np.uint8)
    #RAY_dis = np.zeros(1920*1080*3)
    
    previous_RIO = np.zeros((HEIGHT//2,WIDTH//2),dtype=np.uint8)
    previous_RIO_sum = 0    
    RIO_new = np.zeros((HEIGHT//2,WIDTH//2),dtype=np.uint8)    
    #RIO_dis = np.zeros(1920*1080*3)
    
    
    previous_BLACK = np.zeros((HEIGHT,WIDTH),dtype=np.uint8)
    previous_BLACK_sum = 0
    BLACK_new = np.zeros((HEIGHT,WIDTH),dtype=np.uint8)
    #BLACK_dis = np.zeros(1920*1080*3)

    #待写入
    RAYstartframelist = []
    RIOstartframelist = []
    BLACKstartframelist = []

    #进度条
    print("----------")

    while(cap.isOpened()):
        ret, img = cap.read()        
        if ret is False:#没有帧了    
            break 
            
        frame_count = frame_count + 1 #成功读帧，帧数+1
        small_img=cv.resize(img,None,fx=0.5,fy=0.5,interpolation=cv.INTER_AREA)
        
        #进度条
        if frame_count%60==0:
            print('|',end='',flush=True)
            if frame_count%600==0:
                print('')
        
        #HSV判定
        #RAY
        current_RAY = get_mask(small_img,LOWER_RAY,UPPER_RAY,RAY_KERNEL_SIZE)
        current_RAY_sum = cv.countNonZero(current_RAY)
        RAY_new=cv.bitwise_and(current_RAY,cv.bitwise_xor(current_RAY,previous_RAY))
        RAY_new_sum=cv.countNonZero(RAY_new)       
        RAY_dis_sum=previous_RAY_sum+RAY_new_sum-current_RAY_sum
        
        #RAY终止      判定起始与终止. 先判终止后判开始避免秒瞬间结束
        if (RAY_dis_sum>SUB_END_NUM) & (RAY_dis_sum/(previous_RAY_sum+1) > 0.5):        #超过一半消失则判定为结束
            for st in RAYstartframelist:
                writetimestamp(ASS_FILENAME,FPS,st,frame_count,"ray")
            RAYstartframelist=[] #清空列表，待复用
        #RAY起始
        if (RAY_new_sum>SUB_START_NUM) & (RAY_new_sum/(current_RAY_sum+1) > 0.3):
            RAYstartframelist.append(frame_count)   #起始时间点向下取整(0.01s)
        
        #RIO
        current_RIO = get_mask(small_img,LOWER_RIO,UPPER_RIO,RIO_KERNEL_SIZE)
        current_RIO_sum = cv.countNonZero(current_RIO)
        RIO_new=cv.bitwise_and(current_RIO,cv.bitwise_xor(current_RIO,previous_RIO))
        RIO_new_sum=cv.countNonZero(RIO_new)       
        RIO_dis_sum=previous_RIO_sum+RIO_new_sum-current_RIO_sum
        
        #RIO终止
        if (RIO_dis_sum>SUB_END_NUM) & (RIO_dis_sum/(previous_RIO_sum+1) > 0.5):
            for st in RIOstartframelist:
                writetimestamp(ASS_FILENAME,FPS,st,frame_count,"rio")
            RIOstartframelist=[] #清空列表，
        #RIO起始
        if (RIO_new_sum>SUB_START_NUM) & (RIO_new_sum/(current_RIO_sum+1) > 0.3):
            RIOstartframelist.append(frame_count)
        
        #黑字
        current_BLACK = get_mask(img,LOWER_BLACK,UPPER_BLACK,BLACK_KERNEL_SIZE)
        current_BLACK_sum = cv.countNonZero(current_BLACK)
        BLACK_new=cv.bitwise_and(current_BLACK,cv.bitwise_xor(current_BLACK,previous_BLACK))
        BLACK_new_sum=cv.countNonZero(BLACK_new)       
        BLACK_dis_sum=previous_BLACK_sum+BLACK_new_sum-current_BLACK_sum
        
        #黑字终止
        if (BLACK_dis_sum>BLACK_END_NUM) & (BLACK_dis_sum/(previous_BLACK_sum+1) > 0.5): 
            for st in BLACKstartframelist:
                writetimestamp(ASS_FILENAME,FPS,st,frame_count,"BLACK")
            BLACKstartframelist=[]
        #黑字起始
        if (BLACK_new_sum>BLACK_START_NUM):
            BLACKstartframelist.append(frame_count)
        
        
        #处理结束，当前帧 存为 上一帧
        previous_RAY=current_RAY
        previous_RAY_sum=current_RAY_sum
        
        previous_RIO=current_RIO        
        previous_RIO_sum=current_RIO_sum
        
        previous_BLACK=current_BLACK        
        previous_BLACK_sum=current_BLACK_sum

        #每600帧（约10秒）显示一次进度
        if frame_count%600 == 0:        
            PROGRAM_currenttime=time.time()
            print('进度：%d%%'%(100*frame_count/TOTAL_FRAMES))
            ctypes.windll.kernel32.SetConsoleTitleW("(%d%%)%s"%(100*frame_count/TOTAL_FRAMES,VIDEO_FILENAME))
            print("已处理帧数： %d"%frame_count)
            print("已处理至：%s"%(frame_to_time(frame_count,FPS)))
            print("已用时间 %d秒"%(PROGRAM_currenttime-PROGRAM_starttime))
            print("每60帧处理用时 %.2f秒"%(60*(PROGRAM_currenttime-PROGRAM_starttime)/frame_count))
            time_left = (TOTAL_FRAMES - frame_count)*(PROGRAM_currenttime-PROGRAM_starttime)/frame_count
            print("预计剩余时间：%d分%d秒"%(time_left/60,time_left%60))
            print("----------") #进度条

    #收尾可能没结束的字幕
    for st in RAYstartframelist:
        writetimestamp(ASS_FILENAME,FPS,st,frame_count,"ray")

    for st in RIOstartframelist:
        writetimestamp(ASS_FILENAME,FPS,st,frame_count,"rio")

    for st in BLACKstartframelist:
        writetimestamp(ASS_FILENAME,FPS,st,frame_count,"BLACK")

    print("\n处理完成")
    ctypes.windll.kernel32.SetConsoleTitleW("(处理完成)%s"%(VIDEO_FILENAME))
    input('按Enter结束。。。')
        
    #释放资源
    cap.release()
    cv.destroyAllWindows()

